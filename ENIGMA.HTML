<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ENIGMA</title>
<style>
  :root{
    --bg1:#0f2027; --bg2:#203a43; --bg3:#2c5364;
    --card-bg: rgba(255,255,255,0.04);
    --accent1:#4facfe; --accent2:#00f2fe;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family: "Segoe UI", Roboto, Arial, sans-serif;
    background: linear-gradient(135deg,var(--bg1),var(--bg2),var(--bg3));
    color: #eef2f7;
    -webkit-font-smoothing:antialiased;
  }
  header{
    text-align:center;
    padding:18px 12px;
    font-size:45px;
    letter-spacing:1px;
    font-weight:700;
    color:#dffbff;
    border-bottom:1px solid rgba(255,255,255,0.03);
  }
  main{
    padding:20px;
    display:grid;
    grid-template-columns: repeat(auto-fit, minmax(340px, 1fr));
    gap:18px;
    max-width:1200px;
    margin: 18px auto;
  }
  .card{
    background: var(--card-bg);
    border-radius:12px;
    padding:16px;
    box-shadow: 0 8px 30px rgba(0,0,0,0.35);
    backdrop-filter: blur(6px);
    border:1px solid rgba(255,255,255,0.03);
  }
  h2{ margin:6px 0 12px; font-size:1.2rem; color: #d6fbff; }
  label{ display:block; margin:8px 0 6px; font-size:0.9rem; color:#cfeff3;}
  input[type=file], input[type=password], textarea {
    width:100%; padding:10px; border-radius:8px; border: none;
    background: rgba(255,255,255,0.03); color:inherit; resize:vertical;
  }
  textarea{ min-height:120px; }
  .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  .btn{
    background: linear-gradient(90deg,var(--accent1),var(--accent2));
    color:#012; border:none; padding:10px 14px; border-radius:9px; cursor:pointer;
    font-weight:700; box-shadow:0 8px 20px rgba(0,0,0,0.4);
  }
  .btn:hover{ transform:translateY(-2px); }
  .small{ font-size:0.85rem; opacity:0.9; }
  progress{ width:100%; height:10px; border-radius:8px; overflow:hidden; margin-top:10px; }
  progress::-webkit-progress-bar{ background: rgba(255,255,255,0.04); }
  progress::-webkit-progress-value{ background: linear-gradient(90deg,var(--accent1),var(--accent2)); }
  img.preview{ max-width:100%; border-radius:8px; margin-top:10px; display:block; }
  canvas.preview{ max-width:100%; border-radius:8px; margin-top:10px; display:block; background:#000;}
  .status{ margin-top:8px; font-size:0.9rem; color:#bff7ff; opacity:0.95; }
  .analysis-panel{ margin-top:12px; font-family:monospace; font-size:0.9rem; background: rgba(0,0,0,0.25); padding:10px; border-radius:8px; white-space:pre-wrap; max-height:320px; overflow:auto; }
  table{ width:100%; border-collapse:collapse; margin-top:8px; font-size:0.9rem; }
  th,td{ border:1px solid rgba(255,255,255,0.04); padding:6px 8px; text-align:center; }
  th{ background: rgba(255,255,255,0.03); }
</style>
</head>
<body>
<header>ENIGMA</header>

<main>
  <!-- HIDE CARD -->
  <section class="card" id="hide-card">
    <h2>Hide â€” Cover Image to hide content</h2>

    <label>Cover Image</label>
    <input type="file" id="cover-image" accept="image/*">
    <img id="cover-preview" class="preview" style="display:none">

    <label>Secret Text (optional)</label>
    <textarea id="secret-text" placeholder="Type a secret message to hide (optional)"></textarea>

    <label>Secret File (optional)</label>
    <input type="file" id="secret-file">
    <div id="secret-file-info" class="small" style="opacity:0.9"></div>

    <label>Use Encryption?</label>
    <div class="row">
      <input type="checkbox" id="use-encryption">
      <input type="password" id="password" placeholder="Enter password (if checked)" style="flex:1" />
    </div>

    <div style="margin-top:12px" class="row">
      <button class="btn" onclick="hideData()">Hide & Download Stego Image</button>
      <div style="flex:1"></div>
    </div>

    <progress id="hide-progress" value="0" max="100" style="display:block;margin-top:12px"></progress>
    <div id="hide-status" class="status">Ready</div>
  </section>

  <!-- EXTRACT CARD -->
  <section class="card" id="extract-card">
    <h2>Extract â€” Choose Stego Image</h2>

    <label>Stego Image</label>
    <input type="file" id="stego-image" accept="image/*">
    <img id="stego-preview" class="preview" style="display:none">

    <label>Password (if encrypted)</label>
    <input type="password" id="decrypt-password" placeholder="Enter decryption password (if needed)">

    <div style="margin-top:12px" class="row">
      <button class="btn" onclick="extractData()">Extract</button>
      <div style="flex:1"></div>
    </div>

    <progress id="extract-progress" value="0" max="100" style="display:block;margin-top:12px"></progress>
    <div id="extract-status" class="status">Ready</div>

    <div id="extracted-output" style="margin-top:12px"></div>
  </section>

  <!-- COMPARE CARD -->
  <section class="card" id="compare-card">
    <h2>Image Comparison</h2>

    <label>Original Image</label>
    <input type="file" id="original-image" accept="image/*">
    <img id="original-preview" class="preview" style="display:none">

    <label>Stego Image</label>
    <input type="file" id="compare-stego" accept="image/*">
    <img id="compare-preview" class="preview" style="display:none">

    <div style="margin-top:10px" class="row">
      <button class="btn" onclick="compareImages()">Show Difference</button>
      <div style="flex:1"></div>
    </div>

    <canvas id="diff-canvas" class="preview" style="display:none"></canvas>
    <div id="compare-results" class="analysis-panel">Load both images and click "Show Difference".</div>
  </section>
</main>
  <!-- FOOTER -->
  <footer>
    <p>made with ðŸ’™ by Siddu </p>
  </footer>

<script>
/* ------------------------------
   Helpers: Text/bytes and crypto
   ------------------------------ */
function stringToBytes(s){ return new TextEncoder().encode(s); }
function bytesToString(b){ return new TextDecoder().decode(b); }

async function deriveKeyFromPassword(password, salt){
  const pwUtf8 = new TextEncoder().encode(password);
  const baseKey = await crypto.subtle.importKey('raw', pwUtf8, 'PBKDF2', false, ['deriveKey']);
  const derived = await crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 150000, hash: 'SHA-256' },
    baseKey,
    { name: 'AES-GCM', length: 256 },
    false,
    ['encrypt','decrypt']
  );
  return derived;
}
async function encryptBytes(plainBytes, password){
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const key = await deriveKeyFromPassword(password, salt);
  const cipher = await crypto.subtle.encrypt({ name:'AES-GCM', iv }, key, plainBytes);
  return { salt, iv, ciphertext: new Uint8Array(cipher) };
}
async function decryptBytes(salt, iv, ciphertext, password){
  const key = await deriveKeyFromPassword(password, salt);
  const plain = await crypto.subtle.decrypt({ name:'AES-GCM', iv }, key, ciphertext).catch(()=>{ throw new Error('Decryption failed (wrong password or corrupted)') });
  return new Uint8Array(plain);
}

/* --------------------------------------
   LSB embedding/extraction utilities
   -------------------------------------- */
function bytesToBitsArray(bytes){
  const arr=[];
  for(let i=0;i<bytes.length;i++){
    for(let b=7;b>=0;b--) arr.push((bytes[i]>>b)&1);
  }
  return arr;
}
function bitsArrayToBytes(bits){
  const len = Math.floor(bits.length/8);
  const out = new Uint8Array(len);
  for(let i=0;i<len;i++){
    let v=0;
    for(let b=0;b<8;b++) v = (v<<1) | bits[i*8 + b];
    out[i]=v;
  }
  return out;
}
function embedBitsIntoImageData(imageData, bits, progressCb){
  const data = imageData.data;
  const capacity = Math.floor(data.length/4)*3;
  if(bits.length > capacity) throw new Error(`Payload too large. Need ${bits.length} bits, capacity ${capacity} bits.`);
  let idx = 0;
  const total = bits.length;
  for(let i=0;i<data.length && idx<total; i+=4){
    for(let ch=0; ch<3 && idx<total; ch++){
      const pos = i+ch;
      data[pos] = (data[pos] & 0xFE) | bits[idx++];
    }
    if(progressCb && idx % 8192 === 0) progressCb(idx/total);
  }
  if(progressCb) progressCb(1);
  return imageData;
}

/* Extract first n bits (in order) from imageData */
function extractNBitsFromImageData(imageData, n){
  const data = imageData.data;
  const bits = [];
  for(let i=0;i<data.length && bits.length < n; i+=4){
    for(let ch=0; ch<3 && bits.length < n; ch++){
      bits.push(data[i+ch] & 1);
    }
  }
  return bits;
}

/* Extract remaining bits starting from offset (bits already consumed)
   We'll implement an iterator-style read that starts after skipBits */
function extractBitsFromImageDataStarting(imageData, skipBits, nBits){
  const data = imageData.data;
  const bits = [];
  // compute starting pixel index and channel
  // each pixel contributes 3 bits (RGB)
  let startIndex = Math.floor(skipBits / 3); // pixel number
  let startChannel = skipBits % 3; // 0..2
  // iterate pixels starting at startIndex
  const totalPixels = Math.floor(data.length/4);
  for(let px = startIndex; px < totalPixels && bits.length < nBits; px++){
    const base = px * 4;
    for(let ch = startChannel; ch < 3 && bits.length < nBits; ch++){
      bits.push(data[base + ch] & 1);
    }
    // after first pixel, channel starts at 0
    startChannel = 0;
  }
  return bits;
}

/* -----------------------
   UI handlers (previews)
   ----------------------- */
let coverImageData = null;
let secretFileData = null;

document.getElementById('cover-image').addEventListener('change', async function(){
  const f = this.files[0];
  if(!f) return;
  document.getElementById('cover-preview').src = URL.createObjectURL(f);
  document.getElementById('cover-preview').style.display = 'block';
  const img = await loadImageFromFile(f);
  const canvas = document.createElement('canvas');
  canvas.width = img.width; canvas.height = img.height;
  const ctx = canvas.getContext('2d'); ctx.drawImage(img,0,0);
  const id = ctx.getImageData(0,0,canvas.width,canvas.height);
  coverImageData = { canvas, ctx, id, width:canvas.width, height:canvas.height };
});

document.getElementById('secret-file').addEventListener('change', async function(){
  const f = this.files[0];
  if(!f){ secretFileData=null; document.getElementById('secret-file-info').textContent=''; return; }
  document.getElementById('secret-file-info').textContent = `${f.name} â€” ${(f.size/1024).toFixed(1)} KB`;
  const ab = await f.arrayBuffer();
  secretFileData = { name: f.name, size: f.size, bytes: new Uint8Array(ab), type: f.type || 'application/octet-stream' };
});

document.getElementById('stego-image').addEventListener('change', function(){
  const f=this.files[0]; if(!f) return;
  document.getElementById('stego-preview').src = URL.createObjectURL(f);
  document.getElementById('stego-preview').style.display='block';
});

document.getElementById('original-image').addEventListener('change', function(){ const f=this.files[0]; if(f){ document.getElementById('original-preview').src=URL.createObjectURL(f); document.getElementById('original-preview').style.display='block'; } });
document.getElementById('compare-stego').addEventListener('change', function(){ const f=this.files[0]; if(f){ document.getElementById('compare-preview').src=URL.createObjectURL(f); document.getElementById('compare-preview').style.display='block'; } });

async function loadImageFromFile(file){
  return new Promise((res,rej)=>{
    const img = new Image();
    img.onload = ()=> res(img);
    img.onerror = rej;
    img.src = URL.createObjectURL(file);
  });
}

/* -----------------------
   Hide flow (length-prefix)
   ----------------------- */
async function hideData(){
  try{
    setHideStatus('Preparing...');
    document.getElementById('hide-progress').value = 0;

    if(!coverImageData) { alert('Select a cover image first'); return; }

    // Collect text & file
    const text = document.getElementById('secret-text').value || '';
    const hasText = text.trim().length > 0;
    const fileEntry = secretFileData || null;
    const hasFile = !!fileEntry;

    if(!hasText && !hasFile){ alert('Provide secret text and/or a file to hide'); return; }

    // Build metadata JSON
    const metadata = {
      hasText: hasText,
      textLen: hasText ? (new TextEncoder().encode(text)).length : 0,
      hasFile: hasFile,
      fileName: hasFile ? fileEntry.name : null,
      fileSize: hasFile ? fileEntry.size : 0,
      version: 1
    };
    const metadataBytes = stringToBytes(JSON.stringify(metadata));
    const metadataLenBuf = new ArrayBuffer(4);
    new DataView(metadataLenBuf).setUint32(0, metadataBytes.length, false); // big-endian

    // Build final plain payload: [metadataLen(4)] [metadataBytes] [textBytes?] [fileBytes?]
    const textBytes = hasText ? stringToBytes(text) : new Uint8Array(0);
    const fileBytes = hasFile ? fileEntry.bytes : new Uint8Array(0);

    const plainLen = 4 + metadataBytes.length + textBytes.length + fileBytes.length;
    const finalPlain = new Uint8Array(plainLen);
    let off = 0;
    finalPlain.set(new Uint8Array(metadataLenBuf), off); off += 4;
    finalPlain.set(metadataBytes, off); off += metadataBytes.length;
    if(hasText){ finalPlain.set(textBytes, off); off += textBytes.length; }
    if(hasFile){ finalPlain.set(fileBytes, off); off += fileBytes.length; }

    // Encryption?
    const useEnc = document.getElementById('use-encryption').checked;
    let payloadBytes; // payload (without flag/length) that we'll embed
    if(useEnc){
      const password = document.getElementById('password').value;
      if(!password) { alert('Password required for encryption'); return; }
      setHideStatus('Encrypting payload...');
      const enc = await encryptBytes(finalPlain, password); // {salt, iv, ciphertext}
      // payload bytes = salt + iv + ciphertext
      payloadBytes = new Uint8Array(enc.salt.length + enc.iv.length + enc.ciphertext.length);
      let p = 0;
      payloadBytes.set(enc.salt, p); p += enc.salt.length;
      payloadBytes.set(enc.iv, p); p += enc.iv.length;
      payloadBytes.set(enc.ciphertext, p);
    } else {
      // payload bytes are finalPlain
      payloadBytes = finalPlain;
    }

    // Build embed buffer: [flag(1)] [payloadLength(4 BE)] [payloadBytes...]
    const payloadLen = payloadBytes.length;
    const embedBuffer = new Uint8Array(1 + 4 + payloadLen);
    embedBuffer[0] = useEnc ? 1 : 0;
    new DataView(embedBuffer.buffer).setUint32(1, payloadLen, false); // big-endian length
    embedBuffer.set(payloadBytes, 5);

    // Capacity check and embed
    const bits = bytesToBitsArray(embedBuffer);
    const imageCapacityBits = Math.floor(coverImageData.id.data.length / 4) * 3;
    if(bits.length > imageCapacityBits){
      alert(`Cover image too small. Need ${Math.ceil(bits.length/8)} bytes, have capacity ${Math.floor(imageCapacityBits/8)} bytes.`);
      setHideStatus('Cover image too small');
      return;
    }

    setHideStatus('Embedding into image...');
    document.getElementById('hide-progress').value = 5;

    // Use a clone of ImageData so we don't accidentally mutate original reference
    const idClone = new ImageData(new Uint8ClampedArray(coverImageData.id.data), coverImageData.id.width, coverImageData.id.height);
    embedBitsIntoImageData(idClone, bits, (p)=>{
      document.getElementById('hide-progress').value = 5 + Math.floor(p*90);
    });

    // Put back and download
    coverImageData.ctx.putImageData(idClone, 0, 0);
    coverImageData.canvas.toBlob(blob=>{
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'enigma_stego.png';
      document.body.appendChild(a); a.click(); a.remove();
      setTimeout(()=> URL.revokeObjectURL(url), 5000);       
      document.getElementById('hide-progress').value = 100;
      setHideStatus('Stego image created & downloaded âœ”');
    }, 'image/png');

  }catch(err){
    alert('Error: ' + (err.message || err));
    setHideStatus('Error occurred');
    document.getElementById('hide-progress').value = 0;
    console.error(err);
  }
}

/* -------------------------
   Extract flow (length-prefix)
   ------------------------- */
async function extractData(){
  try{
    setExtractStatus('Preparing...');
    document.getElementById('extract-progress').value = 0;
    const file = document.getElementById('stego-image').files[0];
    if(!file){ alert('Select a stego image first'); return; }
    const img = await loadImageFromFile(file);
    const canvas = document.createElement('canvas'); canvas.width=img.width; canvas.height=img.height;
    const ctx = canvas.getContext('2d'); ctx.drawImage(img,0,0);
    const id = ctx.getImageData(0,0,canvas.width,canvas.height);

    setExtractStatus('Reading header (flag + length)...');
    // Extract first 5 bytes => 40 bits
    const headerBits = extractNBitsFromImageData(id, 40); // 5 bytes
    if(headerBits.length < 40) { setExtractStatus('No hidden data (header incomplete)'); return; }
    const headerBytes = bitsArrayToBytes(headerBits);
    const flag = headerBytes[0];
    const payloadLength = new DataView(headerBytes.buffer).getUint32(1, false); // big-endian
    setExtractStatus(`Flag: ${flag}, payload length: ${payloadLength} bytes`);

    // Now extract exactly payloadLength bytes (payloadLength * 8 bits) starting after first 40 bits
    const payloadBits = extractBitsFromImageDataStarting(id, 40, payloadLength * 8);
    if(payloadBits.length < payloadLength * 8){
      setExtractStatus('Embedded payload is truncated (image does not contain full payload)');
      alert('Embedded payload is truncated (image does not contain full payload).');
      return;
    }
    const payloadBytes = bitsArrayToBytes(payloadBits);

    // Now interpret payload according to flag
    if(flag === 0){
      // plain: payloadBytes is finalPlain = [metadataLen(4)] [metadata] [text?] [file?]
      handlePlainExtracted(payloadBytes);
    } else if(flag === 1){
      // encrypted: payload is salt(16) + iv(12) + ciphertext
      if(payloadBytes.length < 16 + 12){ throw new Error('Encrypted payload too short'); }
      const salt = payloadBytes.slice(0,16);
      const iv = payloadBytes.slice(16,28);
      const ciphertext = payloadBytes.slice(28);
      const password = document.getElementById('decrypt-password').value;
      if(!password){ alert('This payload is encrypted â€” enter password in Decryption field'); setExtractStatus('Password required'); return; }
      setExtractStatus('Decrypting payload...');
      try{
        const plain = await decryptBytes(salt, iv, ciphertext, password);
        handlePlainExtracted(plain);
      }catch(e){
        setExtractStatus('Decryption failed');
        alert('Decryption failed: wrong password or corrupted ciphertext');
      }
    } else {
      throw new Error('Unknown payload flag');
    }
  }catch(err){
    alert('Error: ' + (err.message || err));
    setExtractStatus('Error occurred');
    console.error(err);
  }
}

/* Parse plain payload: [metadataLen(4)] [metadata JSON] [text?] [file?] */
function handlePlainExtracted(plainBytes){
  try{
    document.getElementById('extract-progress').value = 100;
    setExtractStatus('Parsing payload...');
    if(plainBytes.length < 4) throw new Error('Payload malformed (too short)');
    const dv = new DataView(plainBytes.buffer, plainBytes.byteOffset, plainBytes.byteLength);
    const metadataLen = dv.getUint32(0, false); // big-endian
    if(plainBytes.length < 4 + metadataLen) throw new Error('Payload truncated (metadata length mismatch)');
    const metadataBytes = plainBytes.slice(4, 4 + metadataLen);
    let metadata;
    try{ metadata = JSON.parse(bytesToString(metadataBytes)); } catch(e){ throw new Error('Metadata JSON parse failed'); }
    let offset = 4 + metadataLen;
    let extractedText = null;
    let extractedFile = null;
    if(metadata.hasText){
      const textLen = metadata.textLen || 0;
      if(plainBytes.length < offset + textLen) throw new Error('Payload truncated (text length mismatch)');
      const textBytes = plainBytes.slice(offset, offset + textLen);
      extractedText = bytesToString(textBytes);
      offset += textLen;
    }
    if(metadata.hasFile){
      const fileSize = metadata.fileSize || 0;
      if(plainBytes.length < offset + fileSize) throw new Error('Payload truncated (file length mismatch)');
      const fileBytes = plainBytes.slice(offset, offset + fileSize);
      extractedFile = { name: metadata.fileName || 'extracted_file', bytes: fileBytes };
      offset += fileSize;
    }
    // Render output UI
    const out = document.getElementById('extracted-output');
    out.innerHTML = '';
    if(extractedText !== null){
      const tCard = document.createElement('div');
      tCard.className = 'card';
      tCard.style.marginTop = '10px';
      tCard.innerHTML = `<h3 style="margin:6px 0 8px;font-size:1rem;color:#dffbff">Extracted Text</h3>
        <textarea readonly style="width:100%;min-height:120px;background:rgba(0,0,0,0.4);color:#e8fff9;padding:10px;border-radius:8px">${extractedText}</textarea>`;
      out.appendChild(tCard);
    }
    if(extractedFile !== null){
      const fCard = document.createElement('div');
      fCard.className='card';
      fCard.style.marginTop='10px';
      const sizeKB = (extractedFile.bytes.length/1024).toFixed(1);
      const btn = document.createElement('button'); btn.className='btn'; btn.textContent = 'Download File';
      btn.onclick = ()=> downloadFile(extractedFile.bytes, extractedFile.name);
      fCard.innerHTML = `<h3 style="margin:6px 0 8px;font-size:1rem;color:#dffbff">Extracted File</h3>
        <div class="small" style="margin-bottom:8px">Name: ${extractedFile.name} â€” ${sizeKB} KB</div>`;
      fCard.appendChild(btn);
      out.appendChild(fCard);
    }
    if(!extractedText && !extractedFile){
      out.textContent = 'No text or file found in payload.';
    }
    setExtractStatus('Extraction complete âœ”');
  }catch(err){
    alert('Error while parsing: ' + (err.message || err));
    setExtractStatus('Parse error');
    console.error(err);
  }
}

/* -------------------------
   Compare images utility
   ------------------------- */
async function compareImages(){
  const f1 = document.getElementById('original-image').files[0];
  const f2 = document.getElementById('compare-stego').files[0];
  if(!f1 || !f2){ alert('Select both original and stego images'); return; }
  const img1 = await loadImageFromFile(f1);
  const img2 = await loadImageFromFile(f2);
  if(img1.width !== img2.width || img1.height !== img2.height){ alert('Images must be same dimensions to compare'); return; }
  const c1 = document.createElement('canvas'); c1.width = img1.width; c1.height = img1.height;
  const c2 = document.createElement('canvas'); c2.width = img2.width; c2.height = img2.height;
  const ctx1 = c1.getContext('2d'); const ctx2 = c2.getContext('2d');
  ctx1.drawImage(img1,0,0); ctx2.drawImage(img2,0,0);
  const d1 = ctx1.getImageData(0,0,c1.width,c1.height);
  const d2 = ctx2.getImageData(0,0,c2.width,c2.height);
  const diffCanvas = document.getElementById('diff-canvas');
  diffCanvas.width = c1.width; diffCanvas.height = c1.height;
  const dctx = diffCanvas.getContext('2d');
  const out = dctx.createImageData(c1.width, c1.height);
  let changedPixels = 0, sumSq = 0, lsbChanges = 0;
  for(let i=0;i<d1.data.length;i+=4){
    const r1=d1.data[i], g1=d1.data[i+1], b1=d1.data[i+2];
    const r2=d2.data[i], g2=d2.data[i+1], b2=d2.data[i+2];
    const dr = Math.abs(r1-r2), dg = Math.abs(g1-g2), db = Math.abs(b1-b2);
    if(dr || dg || db) changedPixels++;
    out.data[i] = Math.min(255, dr*6);
    out.data[i+1] = Math.min(255, dg*6);
    out.data[i+2] = Math.min(255, db*6);
    out.data[i+3] = 255;
    sumSq += (r1-r2)*(r1-r2) + (g1-g2)*(g1-g2) + (b1-b2)*(b1-b2);
    if(((r1&1)!=(r2&1))) lsbChanges++;
    if(((g1&1)!=(g2&1))) lsbChanges++;
    if(((b1&1)!=(b2&1))) lsbChanges++;
  }
  dctx.putImageData(out,0,0);
  diffCanvas.style.display='block';
  const total = (d1.width * d1.height * 3);
  const mse = sumSq / total;
  const psnr = mse === 0 ? Infinity : (10 * Math.log10((255*255)/mse));
  document.getElementById('compare-results').textContent =
    `Compared dimensions: ${d1.width}Ã—${d1.height}
Changed pixels: ${changedPixels} (${(changedPixels/(d1.width*d1.height)*100).toFixed(4)}%)
LSB bit differences: ${lsbChanges}
MSE: ${mse.toFixed(3)}
PSNR: ${isFinite(psnr)?psnr.toFixed(2)+' dB':'âˆž'}`;
}

/* -------------------------
   Small helpers
   ------------------------- */
function setHideStatus(s){ document.getElementById('hide-status').textContent = s; }
function setExtractStatus(s){ document.getElementById('extract-status').textContent = s; }

function downloadFile(uint8arr, filename){
  const blob = new Blob([uint8arr]);
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove(); 
  setTimeout(()=> URL.revokeObjectURL(url), 5000); // âœ… delay revoke
}

/* wire preview load */
document.getElementById('cover-image').onchange = e=>{ if(e.target.files[0]) coverPreview.src = URL.createObjectURL(e.target.files[0]); };
document.getElementById('stego-image').onchange = e=>{ if(e.target.files[0]) stegoPreview.src = URL.createObjectURL(e.target.files[0]); };
document.getElementById('original-image').onchange = e=>{ if(e.target.files[0]) originalPreview.src = URL.createObjectURL(e.target.files[0]); };
document.getElementById('compare-stego').onchange = e=>{ if(e.target.files[0]) comparePreview.src = URL.createObjectURL(e.target.files[0]); };

</script>
</body>
</html>
